\chapter{PMML integration}
\label{chap:pmml}

\section{PMML project overview}

Predictive Model Markup Language is a standard to represent predictive solutions.
It was developed by Dr. Robert Lee Grossman and the Data Mining Group.
The main goal was to be able to exchange predictive models produced by data mining
and machine learning algorithms between applications. The standard is widely spread across the world,
with over 30 organizations having announced the use of it.\cite{dmgpage}\cite{pmmlpowered}

In our \texttt{Prinz} solution, we are using \texttt{JPMML} library. \texttt{JPMML} is open-source Java's
implementation of the PMML standard. This way we are able to support most of the standatd versions, especially latest
4.0, 4.1, 4.2, 4.3 and 4.4. Modules of the project used in \texttt{Prinz} are \texttt{JPMML-Model},
\texttt{JPMML-Evaluator} and \texttt{JPMML-Transpiler}. The first one is released under the terms and conditions
of the BSD 3-Clause "New" or "Revised" License. Model and transpiler are published under GNU Affero General Public License v3.0.\cite{jpmml}


\section{PMMML model representation}

PMML is based on XML language. The file is composed of several components such as:
\begin{itemize}
    \item header - contains general information about the document,
    \item data dictionary - contains definitions for fields used by the model,
    \item data transformations - maps user data into form used by the mining model,
    \item model - contains the definition of the data mining model,
    \item mining schema - list of all fields used in the model. Can be subset of fileds defined in data dictionary,
    \item targets - allows for post-processing of the predicted value. Can also be used for classification tasks,
    \item output - allows to name desired output fields expected from the model.
\end{itemize}


\section{PMML Repository}

The standard as well as its \texttt{JMPPL} implementation, does not provide any systematic way of versioning and serving models.
Thus, we had to design our own way of storing PMML models. One of the project’s key principle was
to make \texttt{Prinz} open for further integrations and development. To ensure this we have implemented a \texttt{RepositoryClient}.
A generic api \texttt{AbstractRepositoryClient} provides methods to list files, open them and validate. Then the \texttt{RepositoryClientFactory}
knows which implementation of client to choose based on URI’s schema. For now, we have supported local filesystem client and http client.
To integrate a new one, you have to simply implement the abstract api and add one line to factory’s registry.

As mentioned previously, \texttt{PMMLModelRepository} is based on \texttt{RepositoryClient}. By our convention,
the file name should be composed with model name and model version, separated by separator defined in application’s config.

\section{PMML Model and ModelInstance}

\texttt{PMMLModel}s are created based on the data received from scanning the path of the repository.
\texttt{RepositoryClient} returns payloads, where each of them contains basic information of models and input stream of a file.
Then the actual \texttt{PMMLRepository} creates models’ objects from that data.

\texttt{PMMLModel} holds the model’s name and its version. It is also responsible for providing a signature.

\texttt{PMMLModelInstance} represents a tile on Nussknacker’s flow. It is capable of actually running the model and mapping its output to be understood by Nussknacker.
To achieve this, we are also using an evaluator from \texttt{JPMML-Evaluator} library.

\section{PMML Model Signature}

The PMML standard does not provide any separate method of retrieving the signature, rather than reading it from the file.
To get the input signature and also output signature we are using the previously mentioned evaluator from \texttt{JPMML-Evaluator} library.
Then \texttt{PMMLSignatureProvider} is converting each field of signature to our standard and parsing types to types supported by Nussknacker.
We are supporting most of the XMLSchema-2 types.
